name: Continuous Deployment Workflow

on:
  push:
    branches:
      - main
      - development

permissions:
  contents: read
  id-token: write

env:
  GCP_REGION: ${{ vars.GCP_REGION }}
  GKE_CLUSTER: ${{ vars.GKE_CLUSTER }}
  GKE_LOCATION: ${{ vars.GKE_LOCATION }}
  WORKLOAD_IDENTITY_PROVIDER: ${{ secrets.GCP_WORKLOAD_IDENTITY_PROVIDER }}
  GCP_SERVICE_ACCOUNT: ${{ secrets.GCP_SERVICE_ACCOUNT_EMAIL }}
  PACKAGE_PREFIX: '@bardsync/'
  NAMESPACE: ${{ github.ref_name == 'main' && 'prd' || github.ref_name == 'development' && 'dev' || github.ref_name }}
  DOCKER_URL: ${{ vars.GCP_REGION }}-docker.pkg.dev/${{ vars.GCP_PROJECT_ID }}
  COMMIT_SHA: ${{ github.sha }}

concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: false

jobs:
  affected:
    name: Get affected packages
    strategy:
      matrix:
        runs-on: [ubuntu-latest]
        pnpm-version: [10.13.1]
        node-version: [22.17.0]
    runs-on: ${{ matrix.runs-on }}
    outputs:
      packages: ${{ steps.set-output.outputs.packages }}
    steps:
      - name: Checkout code into runner
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install pnpm ${{ matrix.pnpm-version }}
        uses: pnpm/action-setup@v4
        with:
          version: ${{ matrix.pnpm-version }}

      - name: Install Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: pnpm

      - name: Install dependencies
        run: pnpm install --workspace-root --frozen-lockfile

      - name: Derive appropriate SHAs for base and head for `nx affected` commands
        uses: nrwl/nx-set-shas@v4

      - name: Get affected packages as JSON array
        id: set-output
        run: |
          pkgs=$(pnpm exec nx show projects --affected || echo "")
          if [[ -z "$pkgs" ]]; then
            echo "No affected packages were found."
            echo "packages=[]" >> $GITHUB_OUTPUT
            exit 0
          fi
          cleaned_pkgs=$(echo "$pkgs" | sed "s|^${{ env.PACKAGE_PREFIX }}||")
          json_array=$(echo "$cleaned_pkgs" | jq -R -s -c 'split("\n")[:-1]')
          echo "packages=$json_array" >> $GITHUB_OUTPUT

  deploy:
    name: Build & Push & Deploy packages images
    needs: affected
    if: needs.affected.outputs.packages != '[]'
    strategy:
      matrix:
        runs-on: [ubuntu-latest]
        package: ${{ fromJson(needs.affected.outputs.packages) }}
    runs-on: ${{ matrix.runs-on }}
    steps:
      - name: Checkout code into runner
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ env.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ env.GCP_SERVICE_ACCOUNT }}

      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v2

      - name: Authenticate Docker for GCP
        run: gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet

      - name: Set up GKE credentials
        uses: google-github-actions/get-gke-credentials@v2
        with:
          cluster_name: ${{ env.GKE_CLUSTER }}
          location: ${{ env.GKE_LOCATION }}

      - name: Build & Push Docker image
        id: build-image
        run: |
          CLEAN_NAME=${{ matrix.package }}
          IMAGE_NAME="${{ env.DOCKER_URL }}/$CLEAN_NAME/$CLEAN_NAME-${{ env.NAMESPACE }}"

          echo "Building and pushing image for package $CLEAN_NAME > $IMAGE_NAME"
          docker buildx create --use --driver docker-container
          docker buildx build \
            -f "packages/$CLEAN_NAME/Dockerfile" \
            -t "$IMAGE_NAME:latest" \
            -t "$IMAGE_NAME:${{ env.COMMIT_SHA }}" \
            --push \
            .

          echo "name-tagged=$IMAGE_NAME:${{ env.COMMIT_SHA }}" >> $GITHUB_OUTPUT

      - name: Deploy image to GKE
        run: |
          CLEAN_NAME=${{ matrix.package }}
          IMAGE_NAME_TAGGED=${{ steps.build-image.outputs.name-tagged }}

          if ! docker buildx imagetools inspect $IMAGE_NAME_TAGGED; then
            echo "No image found on the registry. Skipping deploy."
            exit 1
          fi
          echo "Deploying package $CLEAN_NAME to GKE"
          kubectl set image deployment/$CLEAN_NAME client=$IMAGE_NAME_TAGGED -n ${{ env.NAMESPACE }}
          for i in {1..3}; do
            if kubectl rollout status deployment/$CLEAN_NAME -n ${{ env.NAMESPACE }}; then
              echo "Deployment succeeded!"
              break
            else
              echo "Rollout not complete, retrying ($i/3)..."
              sleep 10
            fi
            if [ $i -eq 3 ]; then
              echo "Deployment failed after retries"
              exit 1
            fi
          done
